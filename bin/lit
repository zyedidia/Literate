#!/usr/bin/env lua

-- Tomorrow theme CSS
local tomorrow_theme_css = [[/* Tomorrow Theme */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */
.prettyprint {
    background: white;
    font-family: Monaco, 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Monaco, Consolas, monospace;
    font-size: 12px;
    line-height: 1.5;
    border: none;
    padding: 10px;
    margin-left: 1.5em;
}

.pln {
    color: #4d4d4c;
}

@media screen {
    .str {
        color: #718c00;
    }

    .kwd {
        color: #8959a8;
    }

    .com {
        color: #800;
    }

    .typ {
        color: #4271ae;
    }

    .lit {
        color: #f5871f;
    }

    .pun {
        color: #4d4d4c;
    }

    .opn {
        color: #4d4d4c;
    }

    .clo {
        color: #4d4d4c;
    }

    .tag {
        color: #c82829;
    }

    .atn {
        color: #f5871f;
    }

    .atv {
        color: #3e999f;
    }

    .dec {
        color: #f5871f;
    }

    .var {
        color: #c82829;
    }

    .fun {
        color: #4271ae;
    }
}
@media print, projection {
    .str {
        color: #006600;
    }

    .kwd {
        color: #006;
        font-weight: bold;
    }

    .com {
        color: #600;
        font-style: italic;
    }

    .typ {
        color: #404;
        font-weight: bold;
    }

    .lit {
        color: #004444;
    }

    .pun, .opn, .clo {
        color: #444400;
    }

    .tag {
        color: #006;
        font-weight: bold;
    }

    .atn {
        color: #440044;
    }

    .atv {
        color: #006600;
    }
}
/* Specify class=linenums on a pre to get line numbering */
ol.linenums {
    margin-top: 0;
    margin-bottom: 0;
}

/* IE indents via margin-left */
li.L0,
li.L1,
li.L2,
li.L3,
li.L4,
li.L5,
li.L6,
li.L7,
li.L8,
li.L9 {
    /* */
}

/* Alternate shading for lines */
li.L1,
li.L3,
li.L5,
li.L7,
li.L9 {
    /* */
}]]

-- Default CSS
local default_css = [[body {
    margin-left: 4em;
    margin-right: 4em;
    font-size: 14pt;
}
.section {
    page-break-inside: avoid;
}
.codeblock {
    padding-bottom: 15px;
}
pre.prettyprint {
    font-family: Monaco, "Lucida Console", monospace;
    font-size: 11pt;
    padding: 10px;
    border-radius: 10px;
    border: none;
    background: #f1f1f1;
    white-space: pre-wrap;
}
.seealso {
    font-size: 11pt;
}
.codeblock_name {
    font-family: Monaco, "Lucida Console", monospace;
    font-size: 11pt;
    margin-top: 1.25em;
    display: block;
}
a:link {
    color: blue;
    text-decoration: none;
}
a:link:hover {
    color: blue;
    text-decoration: underline;
}
a:visited {
    color: blue;
}
a:link:active {
    color: red;
}
h4 {
    padding-right: 1.25em;
}
h4.noheading {
    margin-bottom: 0px;
}
h1 {
    text-align: center;
}
code {
    font-family: Monaco, "Lucida Console", monospace;
    font-size: 11pt;
    padding: 2px;
}
pre {
    -moz-tab-size: 4; /* Code for Firefox */
    -o-tab-size: 4; /* Code for Opera 10.6-12.1 */
    tab-size: 4;
}
p:not(.notp) {
    margin: 0;
    text-indent: 2em;
}
/* .two-col li { */
/*     display: inline-block; */
/*     width: 50%; */
/*     margin: 0; */
/*     padding: 0; */
/*     vertical-align: top; */
/* } */
.two-col {
    list-style-type: none;
}
.two-col li:before {
    content: '-';
    padding: 5px;
    margin-right: 5px;
    color: orange;
    background-color: white;
    display: inline-block;
}]]


-- stringutil
-- The startswith function
function startswith(str, start)
    return string.sub(str, 1, string.len(start)) == start
end

-- The split function
function split(pString, pPattern)
    local Table = {}  -- NOTE: use {n = 0} in Lua-5.0
    local fpat = "(.-)" .. pPattern
    local last_end = 1
    local s, e, cap = pString:find(fpat, 1)
    while s do
        if s ~= 1 or cap ~= "" then
            table.insert(Table,cap)
        end
        last_end = e+1
        s, e, cap = pString:find(fpat, last_end)
    end
    if last_end <= #pString then
        cap = pString:sub(last_end)
        table.insert(Table, cap)
    end
    return Table
end

-- The strip function
function strip(str)
    return str:gsub("^%s*(.-)%s*$", "%1")
end

-- The chomp function
function chomp(str)
    return str:gsub("\n$", "")
end

-- The literalize function
function literalize(str)
    return str:gsub("[%(%)%.%%%+%-%*%?%[%]%^%$]", function(c) return "%" .. c end)
end


-- fileutil
-- The run function
function run(cmd)
    local handle = io.popen(cmd)
    local result = handle:read("*a")
    handle:close()
    return result
end

-- The write function
function write(outstream, str)
    if outstream == "STDOUT" then
        io.write(str)
    else
        outstream:write(str)
    end
end

-- The file_exists function
function file_exists(file)
    local f = io.open(file, "rb")
    if f then f:close() end
    return f ~= nil
end

-- The lines_from function
function lines_from(file)
    if file ~= nil then
        if not file_exists(file) then 
            print(file, " does not exist!")
            return {}
        end
    end
    lines = {}
    if file ~= nil then
        for line in io.lines(file, "*L") do 
            lines[#lines + 1] = line
        end
    else
        for line in io.lines() do 
            lines[#lines + 1] = line
        end
    end
    return lines
end

-- The readall function
function readall(file)
    local content = ""
    if file ~= nil then
        local f = io.open(file, "rb")
        if f == nil then
            print(file .. " could not be opened")
            return ""
        end
        content = f:read("*all")
        f:close()
    else
        local stat,res = pcall(io.read, "*all")
        if res:match("interrupted") then
            print("\r")
            os.exit()
        end
        content = res
    end
    return content
end

-- The readdir function
function readdir(dir)
    local files = ""
    if os.name() == "Windows" then
        files = run("dir")
    else
        files = run("ls")
    end
    return split(files, "\n")
end

-- The dirname function
function dirname(path)
    if path:match(".-/.-") then
        local name = string.gsub(path, "(.*/)(.*)", "%1")
        return name
    else
        return ''
    end
end

-- The basename function
function basename(path)
    return string.gsub(path, "(.*[/\\])(.*)", "%2")
end

-- The name function
function name(path)
    local filename = basename(path)
    return filename:match"(.*)%..*"
end



-- weave
-- Define the contains function
function contains(tbl, item)
    for key, value in pairs(tbl) do
        if value == item then return key end
    end
    return false
end

function contains_str(tbl, str)
for key, value in pairs(tbl) do
    if string.lower(value) == string.lower(str) then return key end
end
return false
end

-- Define the get_locations function
function get_locations(lines)
    local sectionnum = 0   -- Which section is currently being parsed
    local in_codeblock = false   -- Whether we are parsing a codeblock or not

    for line_num,line in pairs(lines) do
        line = chomp(line) -- Use chomp to remove the \n

        if startswith(line, "@code_type") then
            local command = split(line, " ")
            codetype = command[2]
            codetype_ext = string.sub(command[3], 2, #command[3])
            goto continue
        end

        if startswith(line, "@title") then
            -- Initialize the title variable
            title = strip(string.sub(line, 7, #line))

        elseif startswith(line, "@s") then
            section_linenums[#section_linenums + 1] = line_num
            sectionnum = sectionnum + 1
        elseif line:match("^%-%-%-.*$") then
            -- A codeblock has been defined
            in_codeblock = true
            if string.match(line, "^%-%-%-$") then
                in_codeblock = false
                goto continue
            end
            -- Get the block name
            local block_name = strip(string.sub(line, 4, #line))
            
            local add_to_block = false -- Whether or not this definition has a +=
            if string.match(block_name, "+=") then
                local plus_index = block_name:match'^.*()%+'
                block_name = strip(string.sub(block_name, 1, plus_index-1))
                add_to_block = true
            end

            -- Add the locations to the dict
            if block_locations[block_name] == nil then -- If this block has not been defined in the dict yet
                block_locations[block_name] = {sectionnum} -- Create a new slot for it and add the current section num
            elseif block_locations[block_name][sectionnum] == nil then -- If the current section num isn't already in the array
                block_locations[block_name][#block_locations[block_name] + 1] = sectionnum -- Add it
            end


        elseif in_codeblock and startswith(strip(line), "@{") then
            -- A codeblock has been used
            line = strip(line)
            local block_name = string.sub(line, 3, #line - 1) -- Substring to just get the block name
            
            -- Pretty much the same as before
            if block_use_locations[block_name] == nil then
                block_use_locations[block_name] = {sectionnum}
            elseif block_use_locations[block_name][sectionnum] == nil then
                block_use_locations[block_name][#block_use_locations[block_name] + 1] = sectionnum
            end

        end
        ::continue::
    end
end

-- Define the write_markdown function
function write_markdown(mkdown)
    if mkdown ~= "" then
        local html = mkdown
        html = string.gsub(html, "<", "&lt;")
        html = string.gsub(html, ">", "&gt;")
        html = string.gsub(html, "\"", "&quot;")
        html = markdown(mkdown)
        out = out .. html .. "\n"
    end
end

-- Define the weave function
function weave(lines, source_dir, has_index)
    out = ""

    get_locations(lines)

    -- Set up html
    local start_codeblock = "<pre class=\"prettyprint lang-" .. codetype .. "\">\n"
    local end_codeblock = "</pre>\n"
    
    local scripts = [[<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=]] .. codetype .. [["></script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
                 <script type="text/x-mathjax-config"> MathJax.Hub.Config({tex2jax: {inlineMath: ]] .. "[['$','$']]}}); </script>\n"
    
    -- Get the CSS
    local css = ""
    local files = readdir(source_dir) -- All the files in the current directory
    
    if contains(files, "default.css") then
        css = readall(source_dir .. "/default.css") -- Read the user's default.css
    else
        css = default_css -- Use the default css
    end
    
    if contains(files, "colorscheme.css") then
        css = css .. readall(source_dir .. "/colorscheme.css") -- Read the user's colorscheme.css
    else
        css = css .. tomorrow_theme_css -- Use the default colorscheme
    end
    
    if contains(files, "additions.css") then
        css = css .. readall(source_dir .. "/additions.css") -- Read the user's additions.css
    end

    
    local base_html = [[<!doctype html>
                   <html>
                   <head>
                   <meta charset="utf-8">
                   <title> ]] .. title .. [[ </title>
                   ]] .. scripts .. [[
                   <style>
                   ]] .. css .. [[
                   </style>
                   </head>
                   <body>]]
    
    out = out .. base_html

    -- Set up variables
    local sectionnum = 0 -- Which section number we are currently parsing
    local in_codeblock = false -- Whether or not we are parsing a some code
    local in_prose = false -- Whether or not we are parsing prose
    local markdown = "" -- This variable holds the current markdown that needs to be transformed to html
    
    local cur_codeblock_name = "" -- The name of the current codeblock begin parsed


    for line_num,line in pairs(lines) do
        line = chomp(line)

        if startswith(line, "@code_type") then
            goto continue
        elseif startswith(line, "@comment_type") then
            goto continue
        end

        -- Parse the line
        if line == "" then
            -- This was a blank line
            if in_codeblock then
                out = out .. "\n"
            else
                markdown = markdown .. "\n" -- Tell markdown this was a blank line
            end
            goto continue
        end
        
        if string.match(line, "^%-%-%-.+$") then -- Codeblock began
            -- Begin codeblock
            -- A code block just began
            in_prose = false
            in_codeblock = true
            -- Write the current markdown
            write_markdown(markdown)
            -- Reset the markdown
            markdown = ""
            
            out = out .. "<div class=\"codeblock\">\n"
            local name = strip(string.sub(line, 4, #line)) -- The codeblock name
            
            local adding = false -- Whether or not this block is a +=
            
            if string.match(name, "+=") then
                local plus_index = name:match'^.*()%+'
                name = strip(string.sub(name, 1, plus_index-1))
                adding = true
            end
            
            cur_codeblock_name = name
            file = string.match(name, "^.+%w%.%w+$") -- Whether or not this name is a file name
            
            if block_locations[name] == nil then
                print(inputfilename .. ":error:" .. line_num .. ": Unknown block name: " .. name)
                os.exit()
            end
            
            local definition_location = block_locations[name][1]
            
            local output = name .. " <a href=\"#" .. definition_location .. "\">" .. definition_location .. "</a>" -- Add the link to the definition location
            local plus = ""
            if adding then
                plus = "+"
            end
            output = "{" .. output .. "} " .. plus .. "â‰¡" -- Add the = or +=
            
            if file then
                output = "<b>" .. output .. "</b>" -- If the name is a file, make it bold
            end
            
            out = out .. "<p class=\"notp\"><span class=\"codeblock_name\">" .. output .. "</span></p>\n"
            -- We can now begin pretty printing the code that comes next
            out = out .. start_codeblock

        elseif string.match(line, "^%-%-%-$") then -- Codeblock ended
            -- End codeblock
            -- A code block just ended
            in_prose = true
            in_codeblock = false
            
            -- First start by ending the pretty printing
            out = out .. end_codeblock
            -- This was stored when the code block began
            local name = cur_codeblock_name
            
            -- Write any "see also" links
            local locations = block_locations[name]
            if block_locations[name] == nil then
                print(inputfilename .. ":error:" .. line_num .. ":Unknown block name: " .. name)
                os.exit()
            end
            
            if #locations > 1 then
                local links = "" -- This will hold the html for the links
                local loopnum = 0
                for i = 2,#locations do
                    local location = locations[i]
                    if location ~= sectionnum then
                        loopnum = loopnum + 1
                        local punc = "" -- We might need a comma or 'and'
                        if loopnum > 1 and loopnum < #locations-1 then
                            punc = ","
                        elseif loopnum == #locations-1 and loopnum > 1 then
                            punc = " and"
                        end
                        links = links .. punc .. " <a href=\"#" .. location .. "\">" .. location .. "</a>"
                    end
                end
                if loopnum > 0 then
                    local plural = ""
                    if loopnum > 1 then
                        plural = "s"
                    end
                    out = out .. "<p class=\"seealso\">See also section" .. plural .. links .. ".</p>\n"
                end
            end

            -- Write any "used in" links
            -- Top level codeblocks such as files are never used, so we have to check here
            if block_use_locations[name] ~= nil then
                local locations = block_use_locations[name]
                local plural = ""
                if #locations > 1 then
                    plural = "s"
                end
                local output = "<p class=\"seealso\">This code is used in section" .. plural
                for i = 1,#locations do
                    local location = locations[i]
                    local punc = ""
                    if i > 1 and i < #locations then
                        punc = ","
                    elseif i == #locations and i ~= 1 then
                        punc = " and"
                    end
                    output = output .. punc .. " <a href=\"#" .. location .. "\">" .. location .. "</a>"
                end
                output = output .. ".</p>\n"
                out = out .. output
            end

            -- Close the "codeblock" div
            out = out .. "</div>\n"

        elseif startswith(line, "@s") and not in_codeblock then -- Section began
            -- Create a new section
            if sectionnum > 1 then
                -- Every section is part of a div. Here we close the last one, and open a new one
                out = out .. "</div>"
            end
            if sectionnum > 0 then
                out = out .. "<div class=\"section\">\n"
            end
            
            -- Write the markdown. It is possible that the last section had no code and was only prose.
            write_markdown(markdown)
            -- Reset the markdown
            markdown = ""
            
            in_section = true
            sectionnum = sectionnum + 1
            heading_title = strip(string.sub(line, 3, #line))
            local class = ""
            if heading_title == "" then
                class = "class=\"noheading\""
            end
            out = out .. "<p class=\"notp\" id=\"" .. sectionnum .. "\"></p><h4 ".. class .. ">" .. sectionnum .. ". ".. heading_title .. "</h4>\n"

        elseif startswith(line, "@title") and not in_codeblock then -- Title created
            -- Create the title
            local title = strip(string.sub(line, 7, #line))
            out = out .. "<h1>" .. title .. "</h1>\n"

        elseif startswith(line, "@include") and not in_codeblock then -- Inline the html given
            -- Include the given file
            local filename = basename(strip(line:sub(10)))
            local filetype = filename:match(".*%.(.*)")
            local file = source_dir .. "/" .. strip(line:sub(10))
            if not file_exists(file) then
                print(inputfilename .. ":error:" .. line_num .. ":Included file ".. file .. " does not exist.")
                exit()
            end
            
            if filetype == "html" then
                -- Inline the html in the specified file
                out = out .. readall(file)
                goto continue

            end

        else
            if in_codeblock then
                -- Write out the line of code
                code_lines[line:gsub("%s+", " ")] = line_num
                line = string.gsub(line, "&", "&amp;")
                line = string.gsub(line, "<", "&lt;")
                line = string.gsub(line, ">", "&gt;")
                -- Link any sections in the line
                while string.match(line, "@{.*}") do
                    if not startswith(strip(line), "@{") and in_codeblock then
                        break
                    end
                    local m = string.match(line, "@{.*}")
                    local name = string.sub(m, 3, #m - 1) -- Get the name in curly brackets
                    if block_locations[name] == nil then
                        print(inputfilename .. ":error:" .. line_num .. ":Unknown block name: " .. name)
                        os.exit()
                    end
                    local location = block_locations[name][1]
                
                    if in_codeblock then
                        local anchor = " <a href=\"#" .. location .. "\">" .. location .. "</a>"
                        local links = "<span class=\"nocode\">{" .. name .. anchor .. "}</span>" -- The nocode is so that this is not pretty printed
                        line = string.gsub(line, literalize(m), links)
                    else
                        local anchor = " [" .. location .. "](#" .. location .. ")"
                        local links = "{`" .. name .. "`" .. anchor .. "}"
                        line = string.gsub(line, literalize(m), links)
                    end
                end

                out = out .. line .. "\n"

            else
                -- Add the line to the markdown
                -- Link any sections in the line
                while string.match(line, "@{.*}") do
                    if not startswith(strip(line), "@{") and in_codeblock then
                        break
                    end
                    local m = string.match(line, "@{.*}")
                    local name = string.sub(m, 3, #m - 1) -- Get the name in curly brackets
                    if block_locations[name] == nil then
                        print(inputfilename .. ":error:" .. line_num .. ":Unknown block name: " .. name)
                        os.exit()
                    end
                    local location = block_locations[name][1]
                
                    if in_codeblock then
                        local anchor = " <a href=\"#" .. location .. "\">" .. location .. "</a>"
                        local links = "<span class=\"nocode\">{" .. name .. anchor .. "}</span>" -- The nocode is so that this is not pretty printed
                        line = string.gsub(line, literalize(m), links)
                    else
                        local anchor = " [" .. location .. "](#" .. location .. ")"
                        local links = "{`" .. name .. "`" .. anchor .. "}"
                        line = string.gsub(line, literalize(m), links)
                    end
                end

                markdown = markdown .. line .. "\n"

            end
        end

        ::continue::
    end

    -- Clean up
    write_markdown(markdown)
    -- Close the last section's div
    out = out .. "</div>"
    
    if has_index then
        out = out .. create_index(inputfilename)
    end
    
    out = out .. "</body>\n</html>\n"


    return out
end


-- tangle
-- Define the tangle function
function tangle(lines)
    codeblock_use_lines = {} -- String => Number

    comment_type = ""
    local codeblocks = {} -- String => String
    local block_names = {} -- Number => String
    
    for line_num,line in pairs(lines) do
        line = chomp(line)
        if startswith(line, "@comment_type") then
            comment_type = strip(string.sub(line, 15, #line))
        elseif startswith(line, "---") and not string.match(line, "^---$") then
            -- Get the block name
            local block_name = strip(string.sub(line, 4, #line))
            
            local add_to_block = false -- Whether or not this definition has a +=
            if string.match(block_name, "+=") then
                local plus_index = block_name:match'^.*()%+'
                block_name = strip(string.sub(block_name, 1, plus_index-1))
                add_to_block = true
            end

            -- Get the code
            local code = ""
            while true do
                line_num = line_num + 1
                if line_num > #lines then
                    print(inputfilename .. ":error:" .. #lines .. ":".. block_name .. " is never closed")
                    os.exit()
                end
            
                if startswith(strip(line), "@{") then
                    local name = line:match("@{(.*)}")
                    codeblock_use_lines[name] = line_num
                end
            
                line = lines[line_num]
                if line == nil then break end
                if chomp(line) == "---" then break end
                code = code .. line .. "\n"
            end

            -- Add the code to the dict
            if add_to_block then
                if codeblocks[block_name] ~= nil then
                    codeblocks[block_name] = codeblocks[block_name] .. "\n" .. code
                else
                    print(inputfilename .. ":error:" .. line_num .. ":Unknown block name: " .. block_name)
                    os.exit()
                end
            else
                block_names[#block_names + 1] = block_name
                codeblocks[block_name] = code
            end

        end
    end

    -- Write the code
    found_file = false
    for i,name in pairs(block_names) do
        if string.match(basename(name), "^.+%w%.%w+$") then
            found_file = true
            if stdin then
                outstream = "STDOUT"
                print("\n---- " .. basename(name) .. " ----\n")
            else
                if generate_files then
                    outstream = io.open(outdir .. "/" .. strip(name), "w")
                end
            end
            write_code(name, "", codeblocks, outstream)
            if not stdin then
                if generate_files then
                    outstream:close()
                end
            end
        end
    end
    if not found_file then
        print(inputfilename .. ":error:no file name found. Not writing any code file.")
    end

end

-- Define the write_code function
function write_code(block_name, leading_whitespace, codeblocks, outstream)
    local code = codeblocks[block_name]
    if code == nil then
        print(inputfilename .. ":error:" .. codeblock_use_lines[block_name] .. ":Unknown block name: " .. block_name)
        os.exit()
    end
    local lines = split(code, "\n")

    if comment_type ~= "" then
        if not string.match(block_name, "^.+%w%.%w+$") then
            comment = string.gsub(comment_type, "%%s", block_name)
            if generate_files then
                write(outstream, leading_whitespace .. comment .. "\n")
            end
        end
    end

    for line_num,line in pairs(lines) do
        if startswith(strip(line), "@{") then
            myleading_whitespace = string.match(line, "^(.-)[^%s]")
            line = strip(line)
            write_code(string.sub(line, 3, line:find("}[^}]*$") - 1), leading_whitespace .. myleading_whitespace, codeblocks, outstream)
        else
            if generate_files then
                write(outstream, leading_whitespace .. line .. "\n")
            end
        end
    end

    if generate_files then
        write(outstream, "\n")
    end
end



-- index
function section_for_linenum(linenum)
    -- Get the section number given a line number
    for i = 1,#section_linenums do
        if i == #section_linenums then
            return i
        end
        if linenum < section_linenums[i + 1] then
            return i
        end
    end

end

-- Sort a table
function pairsByKeys (t, f)
    local a = {}
    for n in pairs(t) do table.insert(a, n) end
    table.sort(a, f)
    local i = 0      -- iterator variable
    local iter = function ()   -- iterator function
        i = i + 1
        if a[i] == nil then return nil
        else return a[i], t[a[i]]
        end
    end
    return iter
end

function create_index(inputfile)
    local noctags = os.name() == "Windows"
    if not noctags and run("which ctags") == nil then
        -- print("You do not have ctags installed and it is required for making an index.")
        -- print("If you do not want to receive this message use the -noindex flag.")
        noctags = true
    end

    if not noctags and run("ctags --list-languages") == nil then
        -- print("You have an old version of ctags installed, please update to exuberant or universal ctags if you want an index.")
        -- print("If you do not want to receive this message use the -noindex flag.")
        noctags = true
    end

    local tags = {}
    if not noctags then
        -- Run Ctags on the lit file
        local supported_languages = split(run("ctags --list-languages"), "\n")
        
        if not contains_str(supported_languages, codetype) then
            -- print(codetype .. " is not supported by your version of ctags.")
            noctags = true
        end
        
        run("echo '" .. complete_source:gsub("'", "'\"'\"'") .. "' | lit -code > out.txt")
        local tags_str = run("ctags -x --" .. string.lower(codetype) .. "-kinds=+abcdefghijklmnopqrxtuvwxyzABCDEFGHIJKLMNOPQRXTUVWXYZ  --language-force=" .. string.lower(codetype) .. " out.txt 2>/dev/null")
        run("rm out.txt")
        
        if tags_str == "" then
            -- print(codetype .. " is not supported by your version of ctags.")
            -- print("Please use -noindex if you would not like to create an index.")
            -- return ""
            noctags = true
        end
        
        if not noctags then
            local tags_arr = split(tags_str, "\n")
        
            for _,tag in pairs(tags_arr) do
                if tag ~= "" then
                    local words = split(tag, "%s+")
        
                    local line = tag:match("out.txt%s+([^%s].-)$")
        
                    if code_lines[line] == nil then
                        goto continue
                    end
        
                    local line_num = code_lines[line]
        
                    local name = words[1]
                    local tag_type = words[2]
                    
                    tags[#tags + 1] = {name, tag_type, line_num}
                end
                ::continue::
            end
        end

    end
    -- Create the HTML for the index
    local html = ""
    if #tags > 0 then
        html = html .. "<h5>Identifiers Used</h5>\n"
        html = html .. "<ul class=\"two-col\">\n"
    
        for _,tag in pairs(tags) do
            local section_num = section_for_linenum(tag[3])
            html = html .. "<li><code>" .. tag[1] .. "</code>: <em>" .. tag[2] .. "</em> <a href=\"#" .. section_num .. "\">" .. section_num .. "</a></li>\n"
        end
        html = html .. "</ul>"
    end
    
    if next(block_locations) ~= nil then
        html = html .. "<h5>Code Blocks</h5>\n"
        html = html .. "<ul class=\"two-col\">\n"
    
        -- Sort the block_locations dictionary so that the codeblocks come in order
        for name,locations in pairsByKeys(block_locations) do
            html = html .. "<li><code>" .. name .. "</code>"
            for i = 1,#locations do
                local location = locations[i]
                local p = ", "
                if i == 1 then
                    p = " "
                end
                html = html .. p .. "<a href=\"#" .. location .. "\">" .. location .. "</a>"
            end
            html = html .. "</li>\n"
        end
        html = html .. "</ul>"
        html = "<h3>Index</h3>\n" .. html
    end

    return html
end


-- markdown
local unpack = unpack or table.unpack

local span_transform, encode_backslash_escapes, block_transform, blocks_to_html, blocks_to_html

-- Returns the result of mapping the values in table t through the function f
local function map(t, f)
    local out = {}
    for k,v in pairs(t) do out[k] = f(v,k) end
    return out
end

-- The identity function, useful as a placeholder.
local function identity(text) return text end

-- Functional style if statement. (NOTE: no short circuit evaluation)
local function iff(t, a, b) if t then return a else return b end end

-- Splits the text into an array of separate lines.
local function split(text, sep)
    sep = sep or "\n"
    local lines = {}
    local pos = 1
    while true do
        local b,e = text:find(sep, pos)
        if not b then table.insert(lines, text:sub(pos)) break end
        table.insert(lines, text:sub(pos, b-1))
        pos = e + 1
    end
    return lines
end

-- Converts tabs to spaces
local function detab(text)
    local tab_width = 4
    local function rep(match)
        local spaces = -match:len()
        while spaces<1 do spaces = spaces + tab_width end
        return match .. string.rep(" ", spaces)
    end
    text = text:gsub("([^\n]-)\t", rep)
    return text
end

-- Applies string.find for every pattern in the list and returns the first match
local function find_first(s, patterns, index)
    local res = {}
    for _,p in ipairs(patterns) do
        local match = {s:find(p, index)}
        if #match>0 and (#res==0 or match[1] < res[1]) then res = match end
    end
    return unpack(res)
end

-- If a replacement array is specified, the range [start, stop] in the array is replaced
-- with the replacement array and the resulting array is returned. Without a replacement
-- array the section of the array between start and stop is returned.
local function splice(array, start, stop, replacement)
    if replacement then
        local n = stop - start + 1
        while n > 0 do
            table.remove(array, start)
            n = n - 1
        end
        for i,v in ipairs(replacement) do
            table.insert(array, start, v)
        end
        return array
    else
        local res = {}
        for i = start,stop do
            table.insert(res, array[i])
        end
        return res
    end
end

-- Outdents the text one step.
local function outdent(text)
    text = "\n" .. text
    text = text:gsub("\n  ? ? ?", "\n")
    text = text:sub(2)
    return text
end

-- Indents the text one step.
local function indent(text)
    text = text:gsub("\n", "\n    ")
    return text
end

-- Does a simple tokenization of html data. Returns the data as a list of tokens.
-- Each token is a table with a type field (which is either "tag" or "text") and
-- a text field (which contains the original token data).
local function tokenize_html(html)
    local tokens = {}
    local pos = 1
    while true do
        local start = find_first(html, {"<!%-%-", "<[a-z/!$]", "<%?"}, pos)
        if not start then
            table.insert(tokens, {type="text", text=html:sub(pos)})
            break
        end
        if start ~= pos then table.insert(tokens, {type="text", text = html:sub(pos, start-1)}) end

        local _, stop
        if html:match("^<!%-%-", start) then
            _,stop = html:find("%-%->", start)
        elseif html:match("^<%?", start) then
            _,stop = html:find("?>", start)
        else
            _,stop = html:find("%b<>", start)
        end
        if not stop then
            -- error("Could not match html tag " .. html:sub(start,start+30))
            table.insert(tokens, {type="text", text=html:sub(start, start)})
            pos = start + 1
        else
            table.insert(tokens, {type="tag", text=html:sub(start, stop)})
            pos = stop + 1
        end
    end
    return tokens
end

-- This is used to "hash" data into alphanumeric strings that are unique
-- in the document. (Note that this is not cryptographic hash, the hash
-- function is not one-way.) The hash procedure is used to protect parts
-- of the document from further processing.

local HASH = {
    -- Has the hash been inited.
    inited = false,

    -- The unique string prepended to all hash values. This is to ensure
    -- that hash values do not accidently coincide with an actual existing
    -- string in the document.
    identifier = "",

    -- Counter that counts up for each new hash instance.
    counter = 0,

    -- Hash table.
    table = {}
}

-- Inits hashing. Creates a hash_identifier that doesn't occur anywhere
-- in the text.
local function init_hash(text)
    HASH.inited = true
    HASH.identifier = ""
    HASH.counter = 0
    HASH.table = {}

    local s = "HASH"
    local counter = 0
    local id
    while true do
        id  = s .. counter
        if not text:find(id, 1, true) then break end
        counter = counter + 1
    end
    HASH.identifier = id
end

-- Returns the hashed value for s.
local function hash(s)
    assert(HASH.inited)
    if not HASH.table[s] then
        HASH.counter = HASH.counter + 1
        local id = HASH.identifier .. HASH.counter .. "X"
        HASH.table[s] = id
    end
    return HASH.table[s]
end

-- The protection module is used to "protect" parts of a document
-- so that they are not modified by subsequent processing steps.
-- Protected parts are saved in a table for later unprotection

-- Protection data
local PD = {
    -- Saved blocks that have been converted
    blocks = {},

    -- Block level tags that will be protected
    tags = {"p", "div", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote",
    "pre", "table", "dl", "ol", "ul", "script", "noscript", "form", "fieldset",
    "iframe", "math", "ins", "del"}
}

-- Pattern for matching a block tag that begins and ends in the leftmost
-- column and may contain indented subtags, i.e.
-- <div>
--    A nested block.
--    <div>
--        Nested data.
--     </div>
-- </div>
local function block_pattern(tag)
    return "\n<" .. tag .. ".-\n</" .. tag .. ">[ \t]*\n"
end

-- Pattern for matching a block tag that begins and ends with a newline
local function line_pattern(tag)
    return "\n<" .. tag .. ".-</" .. tag .. ">[ \t]*\n"
end

-- Protects the range of characters from start to stop in the text and
-- returns the protected string.
local function protect_range(text, start, stop)
    local s = text:sub(start, stop)
    local h = hash(s)
    PD.blocks[h] = s
    text = text:sub(1,start) .. h .. text:sub(stop)
    return text
end

-- Protect every part of the text that matches any of the patterns. The first
-- matching pattern is protected first, etc.
local function protect_matches(text, patterns)
    while true do
        local start, stop = find_first(text, patterns)
        if not start then break end
        text = protect_range(text, start, stop)
    end
    return text
end

-- Protects blocklevel tags in the specified text
local function protect(text)
    -- First protect potentially nested block tags
    text = protect_matches(text, map(PD.tags, block_pattern))
    -- Then protect block tags at the line level.
    text = protect_matches(text, map(PD.tags, line_pattern))
    -- Protect <hr> and comment tags
    text = protect_matches(text, {"\n<hr[^>]->[ \t]*\n"})
    text = protect_matches(text, {"\n<!%-%-.-%-%->[ \t]*\n"})
    return text
end

-- Returns true if the string s is a hash resulting from protection
local function is_protected(s)
    return PD.blocks[s]
end

-- Unprotects the specified text by expanding all the nonces
local function unprotect(text)
    for k,v in pairs(PD.blocks) do
        v = v:gsub("%%", "%%%%")
        text = text:gsub(k, v)
    end
    return text
end


-- The block transform functions transform the text on the block level.
-- They work with the text as an array of lines rather than as individual
-- characters.

-- Returns true if the line is a ruler of (char) characters.
-- The line must contain at least three char characters and contain only spaces and
-- char characters.
local function is_ruler_of(line, char)
    if not line:match("^[ %" .. char .. "]*$") then return false end
    if not line:match("%" .. char .. ".*%" .. char .. ".*%" .. char) then return false end
    return true
end

-- Identifies the block level formatting present in the line
local function classify(line)
    local info = {line = line, text = line}

    if line:match("^    ") then
        info.type = "indented"
        info.outdented = line:sub(5)
        return info
    end

    for _,c in ipairs({'*', '-', '_', '='}) do
        if is_ruler_of(line, c) then
            info.type = "ruler"
            info.ruler_char = c
            return info
        end
    end

    if line == "" then
        info.type = "blank"
        return info
    end

    if line:match("^(#+)[ \t]*(.-)[ \t]*#*[ \t]*$") then
        local m1, m2 = line:match("^(#+)[ \t]*(.-)[ \t]*#*[ \t]*$")
        info.type = "header"
        info.level = m1:len()
        info.text = m2
        return info
    end

    if line:match("^ ? ? ?(%d+)%.[ \t]+(.+)") then
        local number, text = line:match("^ ? ? ?(%d+)%.[ \t]+(.+)")
        info.type = "list_item"
        info.list_type = "numeric"
        info.number = 0 + number
        info.text = text
        return info
    end

    if line:match("^ ? ? ?([%*%+%-])[ \t]+(.+)") then
        local bullet, text = line:match("^ ? ? ?([%*%+%-])[ \t]+(.+)")
        info.type = "list_item"
        info.list_type = "bullet"
        info.bullet = bullet
        info.text= text
        return info
    end

    if line:match("^>[ \t]?(.*)") then
        info.type = "blockquote"
        info.text = line:match("^>[ \t]?(.*)")
        return info
    end

    if is_protected(line) then
        info.type = "raw"
        info.html = unprotect(line)
        return info
    end

    info.type = "normal"
    return info
end

-- Find headers constisting of a normal line followed by a ruler and converts them to
-- header entries.
local function headers(array)
    local i = 1
    while i <= #array - 1 do
        if array[i].type  == "normal" and array[i+1].type == "ruler" and
            (array[i+1].ruler_char == "-" or array[i+1].ruler_char == "=") then
            local info = {line = array[i].line}
            info.text = info.line
            info.type = "header"
            info.level = iff(array[i+1].ruler_char == "=", 1, 2)
            table.remove(array, i+1)
            array[i] = info
        end
        i = i + 1
    end
    return array
end

-- Find list blocks and convert them to protected data blocks
local function lists(array, sublist)
    local function process_list(arr)
        local function any_blanks(arr)
            for i = 1, #arr do
                if arr[i].type == "blank" then return true end
            end
            return false
        end

        local function split_list_items(arr)
            local acc = {arr[1]}
            local res = {}
            for i=2,#arr do
                if arr[i].type == "list_item" then
                    table.insert(res, acc)
                    acc = {arr[i]}
                else
                    table.insert(acc, arr[i])
                end
            end
            table.insert(res, acc)
            return res
        end

        local function process_list_item(lines, block)
            while lines[#lines].type == "blank" do
                table.remove(lines)
            end

            local itemtext = lines[1].text
            for i=2,#lines do
                itemtext = itemtext .. "\n" .. outdent(lines[i].line)
            end
            if block then
                itemtext = block_transform(itemtext, true)
                if not itemtext:find("<pre>") then itemtext = indent(itemtext) end
                return "    <li>" .. itemtext .. "</li>"
            else
                local lines = split(itemtext)
                lines = map(lines, classify)
                lines = lists(lines, true)
                lines = blocks_to_html(lines, true)
                itemtext = table.concat(lines, "\n")
                if not itemtext:find("<pre>") then itemtext = indent(itemtext) end
                return "    <li>" .. itemtext .. "</li>"
            end
        end

        local block_list = any_blanks(arr)
        local items = split_list_items(arr)
        local out = ""
        for _, item in ipairs(items) do
            out = out .. process_list_item(item, block_list) .. "\n"
        end
        if arr[1].list_type == "numeric" then
            return "<ol>\n" .. out .. "</ol>"
        else
            return "<ul>\n" .. out .. "</ul>"
        end
    end

    -- Finds the range of lines composing the first list in the array. A list
    -- starts with (^ list_item) or (blank list_item) and ends with
    -- (blank* $) or (blank normal).
    --
    -- A sublist can start with just (list_item) does not need a blank...
    local function find_list(array, sublist)
        local function find_list_start(array, sublist)
            if array[1].type == "list_item" then return 1 end
            if sublist then
                for i = 1,#array do
                    if array[i].type == "list_item" then return i end
                end
            else
                for i = 1, #array-1 do
                    if array[i].type == "blank" and array[i+1].type == "list_item" then
                        return i+1
                    end
                end
            end
            return nil
        end
        local function find_list_end(array, start)
            local pos = #array
            for i = start, #array-1 do
                if array[i].type == "blank" and array[i+1].type ~= "list_item"
                    and array[i+1].type ~= "indented" and array[i+1].type ~= "blank" then
                    pos = i-1
                    break
                end
            end
            while pos > start and array[pos].type == "blank" do
                pos = pos - 1
            end
            return pos
        end

        local start = find_list_start(array, sublist)
        if not start then return nil end
        return start, find_list_end(array, start)
    end

    while true do
        local start, stop = find_list(array, sublist)
        if not start then break end
        local text = process_list(splice(array, start, stop))
        local info = {
            line = text,
            type = "raw",
            html = text
        }
        array = splice(array, start, stop, {info})
    end

    -- Convert any remaining list items to normal
    for _,line in ipairs(array) do
        if line.type == "list_item" then line.type = "normal" end
    end

    return array
end

-- Find and convert blockquote markers.
local function blockquotes(lines)
    local function find_blockquote(lines)
        local start
        for i,line in ipairs(lines) do
            if line.type == "blockquote" then
                start = i
                break
            end
        end
        if not start then return nil end

        local stop = #lines
        for i = start+1, #lines do
            if lines[i].type == "blank" or lines[i].type == "blockquote" then
            elseif lines[i].type == "normal" then
                if lines[i-1].type == "blank" then stop = i-1 break end
            else
                stop = i-1 break
            end
        end
        while lines[stop].type == "blank" do stop = stop - 1 end
        return start, stop
    end

    local function process_blockquote(lines)
        local raw = lines[1].text
        for i = 2,#lines do
            raw = raw .. "\n" .. lines[i].text
        end
        local bt = block_transform(raw)
        if not bt:find("<pre>") then bt = indent(bt) end
        return "<blockquote>\n    " .. bt ..
            "\n</blockquote>"
    end

    while true do
        local start, stop = find_blockquote(lines)
        if not start then break end
        local text = process_blockquote(splice(lines, start, stop))
        local info = {
            line = text,
            type = "raw",
            html = text
        }
        lines = splice(lines, start, stop, {info})
    end
    return lines
end

-- Find and convert codeblocks.
local function codeblocks(lines)
    local function find_codeblock(lines)
        local start
        for i,line in ipairs(lines) do
            if line.type == "indented" then start = i break end
        end
        if not start then return nil end

        local stop = #lines
        for i = start+1, #lines do
            if lines[i].type ~= "indented" and lines[i].type ~= "blank" then
                stop = i-1
                break
            end
        end
        while lines[stop].type == "blank" do stop = stop - 1 end
        return start, stop
    end

    local function process_codeblock(lines)
        local raw = detab(encode_code(outdent(lines[1].line)))
        for i = 2,#lines do
            raw = raw .. "\n" .. detab(encode_code(outdent(lines[i].line)))
        end
        return "<pre><code>" .. raw .. "\n</code></pre>"
    end

    while true do
        local start, stop = find_codeblock(lines)
        if not start then break end
        local text = process_codeblock(splice(lines, start, stop))
        local info = {
            line = text,
            type = "raw",
            html = text
        }
        lines = splice(lines, start, stop, {info})
    end
    return lines
end

-- Convert lines to html code
function blocks_to_html(lines, no_paragraphs)
    local out = {}
    local i = 1
    while i <= #lines do
        local line = lines[i]
        if line.type == "ruler" then
            table.insert(out, "<hr/>")
        elseif line.type == "raw" then
            table.insert(out, line.html)
        elseif line.type == "normal" then
            local s = line.line

            while i+1 <= #lines and lines[i+1].type == "normal" do
                i = i + 1
                s = s .. "\n" .. lines[i].line
            end

            if no_paragraphs then
                table.insert(out, span_transform(s))
            else
                table.insert(out, "<p>" .. span_transform(s) .. "</p>")
            end
        elseif line.type == "header" then
            local s = "<h" .. line.level .. ">" .. span_transform(line.text) .. "</h" .. line.level .. ">"
            table.insert(out, s)
        else
            table.insert(out, line.line)
        end
        i = i + 1
    end
    return out
end

-- Perform all the block level transforms
function block_transform(text, sublist)
    local lines = split(text)
    lines = map(lines, classify)
    lines = headers(lines)
    lines = lists(lines, sublist)
    lines = codeblocks(lines)
    lines = blockquotes(lines)
    lines = blocks_to_html(lines)
    local text = table.concat(lines, "\n")
    return text
end

-- Debug function for printing a line array to see the result
-- of partial transforms.
local function print_lines(lines)
    for i, line in ipairs(lines) do
        print(i, line.type, line.text or line.line)
    end
end

-- Functions for transforming the text at the span level.

-- These characters may need to be escaped because they have a special
-- meaning in markdown.
escape_chars = "'\\`*_{}[]()>#+-.!'"
escape_table = {}

local function init_escape_table()
    escape_table = {}
    for i = 1,#escape_chars do
        local c = escape_chars:sub(i,i)
        escape_table[c] = hash(c)
    end
end

-- Adds a new escape to the escape table.
local function add_escape(text)
    if not escape_table[text] then
        escape_table[text] = hash(text)
    end
    return escape_table[text]
end

-- Escape characters that should not be disturbed by markdown.
local function escape_special_chars(text)
    local tokens = tokenize_html(text)

    local out = ""
    for _, token in ipairs(tokens) do
        local t = token.text
        if token.type == "tag" then
            -- In tags, encode * and _ so they don't conflict with their use in markdown.
            t = t:gsub("%*", escape_table["*"])
            t = t:gsub("%_", escape_table["_"])
        else
            t = encode_backslash_escapes(t)
        end
        out = out .. t
    end
    return out
end

-- Encode backspace-escaped characters in the markdown source.
function encode_backslash_escapes(t)
    for i=1,escape_chars:len() do
        local c = escape_chars:sub(i,i)
        t = t:gsub("\\%" .. c, escape_table[c])
    end
    return t
end

-- Unescape characters that have been encoded.
local function unescape_special_chars(t)
    local tin = t
    for k,v in pairs(escape_table) do
        k = k:gsub("%%", "%%%%")
        t = t:gsub(v,k)
    end
    if t ~= tin then t = unescape_special_chars(t) end
    return t
end

-- Encode/escape certain characters inside Markdown code runs.
-- The point is that in code, these characters are literals,
-- and lose their special Markdown meanings.
function encode_code(s)
    s = s:gsub("%&", "&amp;")
    s = s:gsub("<", "&lt;")
    s = s:gsub(">", "&gt;")
    for k,v in pairs(escape_table) do
        s = s:gsub("%"..k, v)
    end
    return s
end

-- Handle backtick blocks.
local function code_spans(s)
    s = s:gsub("\\\\", escape_table["\\"])
    s = s:gsub("\\`", escape_table["`"])

    local pos = 1
    while true do
        local start, stop = s:find("`+", pos)
        if not start then return s end
        local count = stop - start + 1
        -- Find a matching numbert of backticks
        local estart, estop = s:find(string.rep("`", count), stop+1)
        local brstart = s:find("\n", stop+1)
        if estart and (not brstart or estart < brstart) then
            local code = s:sub(stop+1, estart-1)
            code = code:gsub("^[ \t]+", "")
            code = code:gsub("[ \t]+$", "")
            code = code:gsub(escape_table["\\"], escape_table["\\"] .. escape_table["\\"])
            code = code:gsub(escape_table["`"], escape_table["\\"] .. escape_table["`"])
            code = "<code>" .. encode_code(code) .. "</code>"
            code = add_escape(code)
            s = s:sub(1, start-1) .. code .. s:sub(estop+1)
            pos = start + code:len()
        else
            pos = stop + 1
        end
    end
    return s
end

-- Encode alt text... enodes &, and ".
local function encode_alt(s)
    if not s then return s end
    s = s:gsub('&', '&amp;')
    s = s:gsub('"', '&quot;')
    s = s:gsub('<', '&lt;')
    return s
end

-- Handle image references
local function images(text)
    local function reference_link(alt, id)
        alt = encode_alt(alt:match("%b[]"):sub(2,-2))
        id = id:match("%[(.*)%]"):lower()
        if id == "" then id = text:lower() end
        link_database[id] = link_database[id] or {}
        if not link_database[id].url then return nil end
        local url = link_database[id].url or id
        url = encode_alt(url)
        local title = encode_alt(link_database[id].title)
        if title then title = " title=\"" .. title .. "\"" else title = "" end
        return add_escape ('<img src="' .. url .. '" alt="' .. alt .. '"' .. title .. "/>")
    end

    local function inline_link(alt, link)
        alt = encode_alt(alt:match("%b[]"):sub(2,-2))
        local url, title = link:match("%(<?(.-)>?[ \t]*['\"](.+)['\"]")
        url = url or link:match("%(<?(.-)>?%)")
        url = encode_alt(url)
        title = encode_alt(title)
        if title then
            return add_escape('<img src="' .. url .. '" alt="' .. alt .. '" title="' .. title .. '"/>')
        else
            return add_escape('<img src="' .. url .. '" alt="' .. alt .. '"/>')
        end
    end

    text = text:gsub("!(%b[])[ \t]*\n?[ \t]*(%b[])", reference_link)
    text = text:gsub("!(%b[])(%b())", inline_link)
    return text
end

-- Handle anchor references
local function anchors(text)
    local function reference_link(text, id)
        text = text:match("%b[]"):sub(2,-2)
        id = id:match("%b[]"):sub(2,-2):lower()
        if id == "" then id = text:lower() end
        link_database[id] = link_database[id] or {}
        if not link_database[id].url then return nil end
        local url = link_database[id].url or id
        url = encode_alt(url)
        local title = encode_alt(link_database[id].title)
        if title then title = " title=\"" .. title .. "\"" else title = "" end
        return add_escape("<a href=\"" .. url .. "\"" .. title .. ">") .. text .. add_escape("</a>")
    end

    local function inline_link(text, link)
        text = text:match("%b[]"):sub(2,-2)
        local url, title = link:match("%(<?(.-)>?[ \t]*['\"](.+)['\"]")
        title = encode_alt(title)
        url  = url or  link:match("%(<?(.-)>?%)") or ""
        url = encode_alt(url)
        if title then
            return add_escape("<a href=\"" .. url .. "\" title=\"" .. title .. "\">") .. text .. "</a>"
        else
            return add_escape("<a href=\"" .. url .. "\">") .. text .. add_escape("</a>")
        end
    end

    text = text:gsub("(%b[])[ \t]*\n?[ \t]*(%b[])", reference_link)
    text = text:gsub("(%b[])(%b())", inline_link)
    return text
end

-- Handle auto links, i.e. <http://www.google.com/>.
local function auto_links(text)
    local function link(s)
        return add_escape("<a href=\"" .. s .. "\">") .. s .. "</a>"
    end
    -- Encode chars as a mix of dec and hex entitites to (perhaps) fool
    -- spambots.
    local function encode_email_address(s)
        -- Use a deterministic encoding to make unit testing possible.
        -- Code 45% hex, 45% dec, 10% plain.
        local hex = {code = function(c) return "&#x" .. string.format("%x", c:byte()) .. ";" end, count = 1, rate = 0.45}
        local dec = {code = function(c) return "&#" .. c:byte() .. ";" end, count = 0, rate = 0.45}
        local plain = {code = function(c) return c end, count = 0, rate = 0.1}
        local codes = {hex, dec, plain}
        local function swap(t,k1,k2) local temp = t[k2] t[k2] = t[k1] t[k1] = temp end

        local out = ""
        for i = 1,s:len() do
            for _,code in ipairs(codes) do code.count = code.count + code.rate end
            if codes[1].count < codes[2].count then swap(codes,1,2) end
            if codes[2].count < codes[3].count then swap(codes,2,3) end
            if codes[1].count < codes[2].count then swap(codes,1,2) end

            local code = codes[1]
            local c = s:sub(i,i)
            -- Force encoding of "@" to make email address more invisible.
            if c == "@" and code == plain then code = codes[2] end
            out = out .. code.code(c)
            code.count = code.count - 1
        end
        return out
    end
    local function mail(s)
        s = unescape_special_chars(s)
        local address = encode_email_address("mailto:" .. s)
        local text = encode_email_address(s)
        return add_escape("<a href=\"" .. address .. "\">") .. text .. "</a>"
    end
    -- links
    text = text:gsub("<(https?:[^'\">%s]+)>", link)
    text = text:gsub("<(ftp:[^'\">%s]+)>", link)

    -- mail
    text = text:gsub("<mailto:([^'\">%s]+)>", mail)
    text = text:gsub("<([-.%w]+%@[-.%w]+)>", mail)
    return text
end

-- Encode free standing amps (&) and angles (<)... note that this does not
-- encode free >.
local function amps_and_angles(s)
    -- encode amps not part of &..; expression
    local pos = 1
    while true do
        local amp = s:find("&", pos)
        if not amp then break end
        local semi = s:find(";", amp+1)
        local stop = s:find("[ \t\n&]", amp+1)
        if not semi or (stop and stop < semi) or (semi - amp) > 15 then
            s = s:sub(1,amp-1) .. "&amp;" .. s:sub(amp+1)
            pos = amp+1
        else
            pos = amp+1
        end
    end

    -- encode naked <'s
    s = s:gsub("<([^a-zA-Z/?$!])", "&lt;%1")
    s = s:gsub("<$", "&lt;")

    -- what about >, nothing done in the original markdown source to handle them
    return s
end

-- Handles emphasis markers (* and _) in the text.
local function emphasis(text)
    for _, s in ipairs {"%*%*"} do
        text = text:gsub(s .. "([^%s][%*%_]?)" .. s, "<strong>%1</strong>")
        text = text:gsub(s .. "([^%s][^<>]-[^%s][%*%_]?)" .. s, "<strong>%1</strong>")
    end
    for _, s in ipairs {"%*"} do
        text = text:gsub(s .. "([^%s_])" .. s, "<em>%1</em>")
        text = text:gsub(s .. "(<strong>[^%s_]</strong>)" .. s, "<em>%1</em>")
        text = text:gsub(s .. "([^%s_][^<>_]-[^%s_])" .. s, "<em>%1</em>")
        text = text:gsub(s .. "([^<>_]-<strong>[^<>_]-</strong>[^<>_]-)" .. s, "<em>%1</em>")
    end
    return text
end

-- Handles line break markers in the text.
local function line_breaks(text)
    return text:gsub("  +\n", " <br/>\n")
end

-- Perform all span level transforms.
function span_transform(text)
    text = code_spans(text)
    text = escape_special_chars(text)
    text = images(text)
    text = anchors(text)
    text = auto_links(text)
    text = amps_and_angles(text)
    text = emphasis(text)
    text = line_breaks(text)
    return text
end

-- Cleanup the text by normalizing some possible variations to make further
-- processing easier.
local function cleanup(text)
    -- Standardize line endings
    text = text:gsub("\r\n", "\n")  -- DOS to UNIX
    text = text:gsub("\r", "\n")    -- Mac to UNIX

    -- Convert all tabs to spaces
    text = detab(text)

    -- Strip lines with only spaces and tabs
    while true do
        local subs
        text, subs = text:gsub("\n[ \t]+\n", "\n\n")
        if subs == 0 then break end
    end

    return "\n" .. text .. "\n"
end

-- Strips link definitions from the text and stores the data in a lookup table.
local function strip_link_definitions(text)
    local linkdb = {}

    local function link_def(id, url, title)
        id = id:match("%[(.+)%]"):lower()
        linkdb[id] = linkdb[id] or {}
        linkdb[id].url = url or linkdb[id].url
        linkdb[id].title = title or linkdb[id].title
        return ""
    end

    local def_no_title = "\n ? ? ?(%b[]):[ \t]*\n?[ \t]*<?([^%s>]+)>?[ \t]*"
    local def_title1 = def_no_title .. "[ \t]+\n?[ \t]*[\"'(]([^\n]+)[\"')][ \t]*"
    local def_title2 = def_no_title .. "[ \t]*\n[ \t]*[\"'(]([^\n]+)[\"')][ \t]*"
    local def_title3 = def_no_title .. "[ \t]*\n?[ \t]+[\"'(]([^\n]+)[\"')][ \t]*"

    text = text:gsub(def_title1, link_def)
    text = text:gsub(def_title2, link_def)
    text = text:gsub(def_title3, link_def)
    text = text:gsub(def_no_title, link_def)
    return text, linkdb
end

link_database = {}

-- Main markdown processing function
function markdown(text)
    init_hash(text)
    init_escape_table()

    text = cleanup(text)
    text = protect(text)
    text, link_database = strip_link_definitions(text)
    text = block_transform(text)
    text = unescape_special_chars(text)
    return text
end

-- Expose markdown function to the world
md = { markdown = markdown }

-- Class for parsing command-line options
local OptionParser = {}
OptionParser.__index = OptionParser

-- Creates a new option parser
function OptionParser:new()
    local o = {short = {}, long = {}}
    setmetatable(o, self)
    return o
end

-- Calls f() whenever a flag with specified short and long name is encountered
function OptionParser:flag(short, long, f)
    local info = {type = "flag", f = f}
    if short then self.short[short] = info end
    if long then self.long[long] = info end
end

-- Calls f(param) whenever a parameter flag with specified short and long name is encountered
function OptionParser:param(short, long, f)
    local info = {type = "param", f = f}
    if short then self.short[short] = info end
    if long then self.long[long] = info end
end

-- Calls f(v) for each non-flag argument
function OptionParser:arg(f)
    self.arg = f
end

-- Runs the option parser for the specified set of arguments. Returns true if all arguments
-- where successfully parsed and false otherwise.
function OptionParser:run(args)
    local pos = 1
    while pos <= #args do
        local arg = args[pos]
        if arg == "--" then
            for i=pos+1,#args do
                if self.arg then self.arg(args[i]) end
                return true
            end
        end
        if arg:match("^%-%-") then
            local info = self.long[arg:sub(3)]
            if not info then print("Unknown flag: " .. arg) return false end
            if info.type == "flag" then
                info.f()
                pos = pos + 1
            else
                param = args[pos+1]
                if not param then print("No parameter for flag: " .. arg) return false end
                info.f(param)
                pos = pos+2
            end
        elseif arg:match("^%-") then
            for i=2,arg:len() do
                local c = arg:sub(i,i)
                local info = self.short[c]
                if not info then print("Unknown flag: -" .. c) return false end
                if info.type == "flag" then
                    info.f()
                else
                    if i == arg:len() then
                        param = args[pos+1]
                        if not param then print("No parameter for flag: -" .. c) return false end
                        info.f(param)
                        pos = pos + 1
                    else
                        param = arg:sub(i+1)
                        info.f(param)
                    end
                    break
                end
            end
            pos = pos + 1
        else
            if self.arg then self.arg(arg) end
            pos = pos + 1
        end
    end
    return true
end

-- Handles the case when markdown is run from the command line
local function run_command_line(arg)
    -- Generate output for input s given options
    local function run(s, options)
        s = markdown(s)
        if not options.wrap_header then return s end
        local header = ""
        if options.header then
            local f = io.open(options.header) or error("Could not open file: " .. options.header)
            header = f:read("*a")
            f:close()
        else
            header = [[
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=CHARSET" />
    <title>TITLE</title>
    <link rel="stylesheet" type="text/css" href="STYLESHEET" />
</head>
<body>
]]
            local title = options.title or s:match("<h1>(.-)</h1>") or s:match("<h2>(.-)</h2>") or
                s:match("<h3>(.-)</h3>") or "Untitled"
            header = header:gsub("TITLE", title)
            if options.inline_style then
                local style = ""
                local f = io.open(options.stylesheet)
                if f then
                    style = f:read("*a") f:close()
                else
                    error("Could not include style sheet " .. options.stylesheet .. ": File not found")
                end
                header = header:gsub('<link rel="stylesheet" type="text/css" href="STYLESHEET" />',
                    "<style type=\"text/css\"><!--\n" .. style .. "\n--></style>")
            else
                header = header:gsub("STYLESHEET", options.stylesheet)
            end
            header = header:gsub("CHARSET", options.charset)
        end
        local footer = "</body></html>"
        if options.footer then
            local f = io.open(options.footer) or error("Could not open file: " .. options.footer)
            footer = f:read("*a")
            f:close()
        end
        return header .. s .. footer
    end

    -- Generate output path name from input path name given options.
    local function outpath(path, options)
        if options.append then return path .. ".html" end
        local m = path:match("^(.+%.html)[^/\\]+$") if m then return m end
        m = path:match("^(.+%.)[^/\\]*$") if m and path ~= m .. "html" then return m .. "html" end
        return path .. ".html"
    end

    -- Default commandline options
    local options = {
        wrap_header = true,
        header = nil,
        footer = nil,
        charset = "utf-8",
        title = nil,
        stylesheet = "default.css",
        inline_style = false
    }
    local help = [[
Usage: markdown.lua [OPTION] [FILE]
Runs the markdown text markup to HTML converter on each file specified on the
command line. If no files are specified, runs on standard input.

No header:
    -n, --no-wrap        Don't wrap the output in <html>... tags.
Custom header:
    -e, --header FILE    Use content of FILE for header.
    -f, --footer FILE    Use content of FILE for footer.
Generated header:
    -c, --charset SET    Specifies charset (default utf-8).
    -i, --title TITLE    Specifies title (default from first <h1> tag).
    -s, --style STYLE    Specifies style sheet file (default default.css).
    -l, --inline-style   Include the style sheet file inline in the header.
Generated files:
    -a, --append         Append .html extension (instead of replacing).
Other options:
    -h, --help           Print this help text.
    -t, --test           Run the unit tests.
]]

    local run_stdin = true
    local op = OptionParser:new()
    op:flag("n", "no-wrap", function () options.wrap_header = false end)
    op:param("e", "header", function (x) options.header = x end)
    op:param("f", "footer", function (x) options.footer = x end)
    op:param("c", "charset", function (x) options.charset = x end)
    op:param("i", "title", function(x) options.title = x end)
    op:param("s", "style", function(x) options.stylesheet = x end)
    op:flag("l", "inline-style", function(x) options.inline_style = true end)
    op:flag("a", "append", function() options.append = true end)
    op:flag("t", "test", function()
        local n = arg[0]:gsub("markdown.lua", "markdown-tests.lua")
        local f = io.open(n)
        if f then
            f:close() dofile(n)
        else
            error("Cannot find markdown-tests.lua")
        end
        run_stdin = false
    end)
    op:flag("h", "help", function() print(help) run_stdin = false end)
    op:arg(function(path)
            local file = io.open(path) or error("Could not open file: " .. path)
            local s = file:read("*a")
            file:close()
            s = run(s, options)
            file = io.open(outpath(path, options), "w") or error("Could not open output file: " .. outpath(path, options))
            file:write(s)
            file:close()
            run_stdin = false
        end
    )

    if not op:run(arg) then
        print(help)
        run_stdin = false
    end

    if run_stdin then
        local s = io.read("*a")
        s = run(s, options)
        io.write(s)
    end
end


-- lit
-- Function to identify the os
if package.config:sub(1, 1) == "/" then
    function os.name()
        return "Unix"
    end
elseif package.config:sub(1, 1) == "\\" then
    function os.name()
        return "Windows"
    end
end

-- Function to resolve @include statements
function resolve_includes(source, source_dir, cur_filename)
    local newSource = ""
    local lines = split(source, "\n")

    local line_num = 0
    for i=1,#lines do
        line_num = line_num + 1
        local line = lines[line_num]

        if startswith(line, "@include") then
            local filename = basename(strip(line:sub(10)))
            if strip(filename) == "" then
                print(cur_filename .. ":error:" .. line_num .. ":No filename given to @change")
                os.exit()
            end
            local filetype = filename:match(".*%.(.*)")
            local file = source_dir .. "/" .. strip(line:sub(10))
            if not file_exists(file) then
                print(cur_filename .. ":error:" .. line_num .. ":Included file ".. file .. " does not exist.")
                os.exit()
            end

            if filetype == "lit" then
                newSource = newSource .. resolve_includes(readall(file), source_dir, file)
            end
        elseif startswith(line, "@change") and not startswith(line, "@change_end") then
            local filename = basename(strip(line:sub(9)))
            if strip(filename) == "" then
                print(cur_filename .. ":error:" .. line_num .. ":No filename given to @change")
                os.exit()
            end

            local filetype = filename:match(".*%.(.*)")
            local file = source_dir .. "/" .. strip(line:sub(9))
            if not file_exists(file) then
                print(cur_filename .. ":error:" .. line_num .. ":Changed file ".. file .. " does not exist.")
                os.exit()
            end

            if filetype == "lit" then
                local search_text = ""
                local replace_text = ""
                local in_search_text = false
                local in_replace_text = false

                local file_source = readall(file)

                while strip(line) ~= "@change_end" do
                    if line_num == #lines + 1 then
                        print(cur_filename .. ":error:" .. #lines .. "Reached end of file with no @change_end")
                        exit()
                    end
                    line_num = line_num + 1
                    line = lines[line_num]

                    if startswith(strip(line), "@replace") then
                        in_replace_text = false
                        in_search_text = true
                        line_num = line_num + 1
                        line = lines[line_num]
                    elseif startswith(strip(line), "@with") then
                        in_search_text = false
                        in_replace_text = true
                        line_num = line_num + 1
                        line = lines[line_num]
                    elseif startswith(strip(line), "@end") then
                        in_search_text = false
                        in_replace_text = false

                        search_text = literalize(chomp(search_text))
                        replace_text = chomp(replace_text)
                        replace_text = replace_text:gsub("%%", "%%%%")

                        file_source = file_source:gsub(search_text, replace_text)
                        search_text = ""
                        replace_text = ""
                    end

                    if in_search_text then
                        search_text = search_text .. line .. "\n"
                    elseif in_replace_text then
                        replace_text = replace_text .. line .. "\n"
                    end
                end

                newSource = newSource .. resolve_includes(file_source, source_dir, file)
            end 

        end
        
        if not startswith(line, "@change_end") then
            newSource = newSource .. line .. "\n"
        end

        if line_num >= #lines then
            break
        end
    end

    return newSource
end


-- Parse the arguments
html = false
code = false
outdir = "."
index = true
generate_files = true

inputfiles = {}

for i=1,#arg do
    argument = arg[i]
    if argument == "-h" then
        print("Usage: lit [-noindex] [-html] [-code] [--out-dir=dir] [--no-output] [file ...]")
        os.exit()
    elseif argument == "-html" then
        html = true
    elseif argument == "-code" then
        code = true
    elseif argument == "-noindex" then
        index = false
    elseif startswith(argument, "--out-dir=") then
        outdir = string.sub(argument, 11, #argument)
    elseif startswith(argument, "--no-output") then
        generate_files = false
    else
        inputfiles[#inputfiles + 1] = argument
    end
end

if not html and not code then
    html = true
    code = true
end

if #inputfiles == 0 then
    -- Use STDIN and STDOUT
    -- Declare a few globals
    title = ""
    block_locations = {} -- String => (Number => Number)
    block_use_locations = {} -- String => (Number => Number)
    
    codetype = ""
    codetype_ext = ""
    
    code_lines = {} -- Number => Number
    section_linenums = {} -- Number => Number

    local source_dir = "."
    
    complete_source = readall()
    complete_source = resolve_includes(complete_source, source_dir, "none")
    local lines = split(complete_source, "\n")
    
    inputfilename = "none"
    
    stdin = true
    if html then
        local output = weave(lines, ".", index)
        if generate_files then
            write("STDOUT", output)
        end
    end
    
    if code then
        tangle(lines)
    end

else
    -- Weave and/or tangle the input files
    for num,file in pairs(inputfiles) do
        -- Declare a few globals
        title = ""
        block_locations = {} -- String => (Number => Number)
        block_use_locations = {} -- String => (Number => Number)
        
        codetype = ""
        codetype_ext = ""
        
        code_lines = {} -- Number => Number
        section_linenums = {} -- Number => Number

    
        inputfilename = file
    
        local source_dir = dirname(file)
        if source_dir == "" then
            source_dir = "."
        end
    
        complete_source = readall(file)
        complete_source = resolve_includes(complete_source, source_dir, file)
        local lines = split(complete_source, "\n")
    
        if html then
            local output = weave(lines, source_dir, index)
            if generate_files then
                local outputstream = io.open(outdir .. "/" .. name(file) .. ".html", "w")
                write(outputstream, output)
                outputstream:close()
            end
        end
        if code then
            tangle(lines)
        end
    end

end


